отличие списка от массива? /вопрос вне урока

Абстракция
Реализация интерфейсов
в интерфейсе нельзя делать Override public String toString

Класс Object
метод public String toString

ArrayLisr<int/Integer>
int - примитивный тип - нет объекта - ошибка создания коллекции
Integer - класс

collection.contains(x);
shape.contains(...) - для фигур? - если передаём фигуру, идёт сравнение по всем элементам

Класс Object
метод public boolean equals(Object, other){...}


Класс Object
метод public int hashCode(){...}
для всех конуструкций Hash*
Все структуры пользуются этим методом
ХэшСет и Мап пользуют его для скорости поиска: делит объекты на группы
HashCode выдаёт целое число на основе полей, существенных для сравниваемых объектов
(по аналогии с еquals)

Принято реализоввывать и equals, и HashSet

alt+insert показывает возможные методы на выбор
По умолчанию, если equals не задан, объекты считаются разными

this - метод, позволяющий ссылаться на самого себя
используется с equals: сравниваю текущий объект (ссылаюсь на него же) с чем-то ещё

this не работает со статическими методами, так как отсутствуют конкретные объекты

удобно использовать, если переменная и передаваемые в неё параметр имеют одинаковое название
this.centre=centre
где this.centre переменная, а centre - параметр, значение которого вкладывается в переменную

нельзя extends + несколько классов
т.е. нельзя наследовать от многих классов сразу, только по цепочке!

но можно расширить класс и реализовать интерфейс или несколько интерфейсов

Comparable - интерфейс
реализуется классами, имеющими натуральный порядок (string, int)
Comparator - интерфейс
сравнивает объекты определённым способом, объекты не обязаны быть сравнимыми






